---
title: 适配配置
description: 适配配置
---

基于规则的，可自定义的适配方案，用于在网页上采集番剧信息从而实现弹幕的自动匹配。

## 基本概念

### 番剧信息

弹幕的自动匹配需要4个基本信息

适配配置允许用户为单独为每个信息提供`XPath`和`regex`

##### 番剧标题

当前播放的番剧的名称。作为关键词用于搜索番剧信息。**必须提供**。

##### 集数

当前播放的是第几集。非分集视频（如电影）可忽略。默认为1。

用于从检索到的番剧信息中选择对应的集数。

##### 季

当前播放的是第几季。存在时，作为关键词的一部分用于搜索番剧信息。

季不一定是数字，任何可以用于消歧义的信息都可以。比如**进击的巨人 最终季 完结篇**中，季为**最终季 完结篇**。

很多时候，季信息是标题的一部分，例如**进击的巨人 最终季 完结篇**。这种情况下不需要额外提供季。

然而有的网站会将季信息提取出来独立在标题外，这时需要提供季的`XPath`和`regex`。

##### 单集标题

当前播放的单集的标题。非分集视频默认为番剧标题。辅助集数进行匹配。

<hr />

以这个标题为例：

```
【我推的孩子】 第二季 第01集 情感演技
```

四个信息分别为：
- 番剧标题：【我推的孩子】
- 季：第二季
- 集数：01（转换为数字时为1）
- 单集标题：情感演技

为了提取这些信息，需要根据网页的结构编写`XPath`和`regex`。

### 规则

适配配置可以从网页的的内容中提取番剧信息，分为两个步骤：
1. 使用`XPath`选择器选择信息所在的节点
2. 使用正则表达式`regex`从节点的文本中提取信息

需满足以下条件：
- 适配配置需要和装填配置关联（装填配置中选择）
- 适配配置只在存在视频时生效
- 每个信息可以可存在多个`XPath`和`regex`，第一个匹配成功的将被使用
- `regex`固定包含`i`标志，表示忽略大小写
- 如果`XPath`选择到多个节点，取第一个
- `XPath`需要选择一个**节点**，不支持如`concat(//*[@id="title"],"")`这样的输出字符串的`XPath`

:::note
节点不一定是元素`Node.ELEMENT_NODE`，也可以是属性`Node.ATTRIBUTE_NODE`或文本`Node.TEXT_NODE`等
:::

插件会监视选择到的节点，当节点的文本发生变化时，插件会重新提取信息，以此判断是否需要更新弹幕。

## 编写规则

:::note
阅读本节前请确保您已经了解`XPath`和`regex`的基本用法。
:::

由于网页的结构各不相同，适配配置需要根据网页的结构编写。

这里考虑两种情况：信息全部在**一个节点**中和信息分散在**多个节点**中。

### 单个节点

默认，也是最普遍的情况。所有信息都存在于一个节点中，这个节点通常是标题。

在表单中表现为勾选 *仅使用标题匹配* 选项。

#### 举个简单的例子

假设网页上有这样一个标题：

<div>
  <p id="anime-title-1" class='title' style={{
    backgroundColor: '#e6e6e6',
    color: '#000',
    padding: '10px',
    borderRadius: '5px',
    width: 'fit-content',
  }}>败犬女主太多了！ 第03集 在战斗开始前就输了</p>
</div>

对应`HTML`

```html
<div id="anime-title-1" class="title">
  <p>败犬女主太多了！ 第03集 在战斗开始前就输了</p>
</div>
```

这个标题包含了番剧标题、集数和单集标题。

从这个标题中提取信息可以使用以下`XPath`：
```text
//*[@id="anime-title-1"]
```

和以下`regex`：
```regex
(?<title>.+) 第(?<episode>\d+)集 (?<episodeTitle>.*)
```

:::note
此处用到了命名捕获组。在单个节点的情况下，必须使用命名捕获组来告诉插件哪个捕获组对应哪个信息。

| **信息类型** | **命名捕获组** |
|--------------|----------------|
| 番剧标题     |  `(?<title>)` |
| 集数         |  `(?<episode>)` |
| 季         |  `(?<season>)` |
| 单集标题     |  `(?<episodeTitle>)` |
:::

:::tip
标题有不同命名规则的情况下可以提供多个`regex`，第一个匹配成功的将被使用。

`XPath`可以从浏览器的开发者工具中复制。复制得到的`XPath`不一定能够覆盖所有情况，可能需要手动调整。
:::

<hr />

#### 再举一个稍复杂的例子：

<div id='anime-title-2' className='anime-title' data-title={'败犬女主太多了！ 第03集 在战斗开始前就输了'}>
  <p style={{
    backgroundColor: '#e6e6e6',
    color: '#000',
    padding: '10px',
    borderRadius: '5px',
    display: 'inline-flex',
    gap: '4px',
  }}>
    <span style={{ fontWeight: 'bold', }}>败犬女主太多了！</span>
    <span style={{ color: '#999' }}>第03集</span>
    <span>在战斗开始前就输了</span>
  </p>
</div>

对应`HTML`

```html
<div id="anime-title-2" class="anime-title" data-title="败犬女主太多了！ 第03集 在战斗开始前就输了">
  <p>
    <span>败犬女主太多了！</span>
    <span>第03集</span>
    <span>在战斗开始前就输了</span>
  </p>
</div>
```

可以发现，虽然信息分散在多个`span`中，但是这些`span`都在同一个`p`和`div`中，选择`div`即可从文本中提取所有信息。
和上面的例子的区别在于这里的空格并非空格符，而是`CSS`样式，需调整`regex`。

另外可以发现`div`中有一个`data-title`属性，这个属性包含了所有信息，也可以选择这个属性。
```XPath
//div/@data-title
```

基于这个原则，理论上所有的网页都可以理解为一个节点，只需要选择最小的包含所有信息的节点，然后使用`regex`提取信息即可。
当然这样可能会导致`regex`变得复杂，所以还可以选择使用**多个节点**的配置。

### 多个节点

即信息分散在多个节点中，这种情况下可以单独提供每个信息的`XPath`和`regex`。

在表单中表现为取消勾选 *仅使用标题匹配* 选项。

接着用上面的例子

```html
<div id="anime-title-2" class="anime-title" data-title="败犬女主太多了！ 第03集 在战斗开始前就输了">
  <p>
    <span>败犬女主太多了！</span>
    <span>第03集</span>
    <span>在战斗开始前就输了</span>
  </p>
</div>
```

可以提供以下`XPath`和`regex`：

**标题**

```text
//*[@id="anime-title-2"]/p/span[1]
```
```regex
.*
```

**集数**

```text
//*[@id="anime-title-2"]/p/span[2]
```
```regex
第(\d+)集
```

**单集标题**

```text
//*[@id="anime-title-2"]/p/span[3]
```
```regex
.*
```

此例子中默认**季**存在于标题中，所以不需要提供季的`XPath`和`regex`。

:::note
在多个节点的情况下，不要使用命名捕获组。可以使用捕获组`()`和非捕获组`(?:)`来忽略不需要的信息。如果存在多个捕获组，取第一个。
:::

<hr />