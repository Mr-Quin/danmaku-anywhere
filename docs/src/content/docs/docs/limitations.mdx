---
title: 工作原理
description: 工作原理
---

Danmaku Anywhere 是一个**纯前端**的浏览器扩展(mv3)，通过注入脚本的方式在网页上显示弹幕。

所有的用户数据都保存在浏览器中，不会上传到服务器。由于弹幕数据量一般会大于浏览器可同步的限制，弹幕数据只保存在当前设备上。

此扩展基本只做两件事情：

1. 获取弹幕
2. 渲染弹幕

## 获取弹幕

弹幕数据保存在`IndexedDB`中，分为两种类型：用户上传和第三方源。

### 用户上传

用户上传作为最基本的获取弹幕的方式，保证扩展可以在不联网的情况下使用。

在能够使用第三方弹幕源的情况下，用户上传的弹幕一般是用来补充第三方弹幕源的不足，比如暂不支持的网址，一些小众网站、自制视频等。

### 第三方源

除了用户上传之外，其他的获取方式均依赖第三方网站，而这些网站普遍不提供官方的 API，

浏览器扩展可以通过`declarativeNetRequest`权限来更改请求头从而绕过`cors`问题。而且由于扩展拥有非常宽松的`host_permissions`权限，发送的请求会自动带上用户的`cookie`，所以可以获取到登录状态下的弹幕。

从设计原则上来说，扩展尽可能的最小化对第三方网站的访问，只获取必要的数据。本地缓存弹幕数据很大一部分是因为这个原因。

#### B站

在启用B站弹幕源时，扩展会先`GET https://www.bilibili.com/`以保证`cookie`正常，然后再确认用户的登录状态，如果未登录则会提示登录。

#### 腾讯

腾讯视频需要的`cookie`通过`javascript`注入，所以无法简单通过`GET`请求来获取。启用时，如果发现`cookie`缺失，会要求用户手动前往腾讯视频页面获取`cookie`。

## 渲染弹幕

渲染指在正确的网站的正确的视频上显示弹幕。

### 匹配网页

扩展安装时会请求所有网站的权限，但并不是所有网站都需要弹幕，因此需要[装填配置](/docs/mount-profile)来告诉扩展哪些网页需要弹幕。

通过白名单的方式，只有在配置中指定的网址模式才会注入脚本并显示弹幕。同时，装填配置可以用来关联网址和其他配置和规则，比如网页适配和弹幕样式（未实装）等。

具体是通过`chrome.scripting.registerContentScripts`来注册脚本，只有在配置中指定的网址模式下才会注入脚本。

最早的设计是在添加**装填配置**时请求配置中网址的权限，这样可以最小化权限的需求，但后来发现这样太麻烦了，用户体验不好，而且权限管理也很繁琐，就索性安装时一次性请求所有权限。

### 匹配视频

弹幕是和视频绑定的，会与视频的播放/暂停同步。扩展始终只会渲染一个视频的弹幕，如果存在多个视频，就需要判断在哪个个视频上显示弹幕。

可能出现多个视频的情况有：
- 广告
- 视频预览，比如鼠标悬停时自动播放的视频
- 隐藏的视频，有些网站会使用隐藏的视频元素来实现一些功能

一开始的设计是用**装填配置**中的**视频元素**来选择某个视频，如果选到了多个，就取第一个。但是要求用户正确配置**视频元素**存在技术门槛，而且有些网站的视频元素是动态的，会随着时间/版本变化，所以这个方法并不可靠。

现在的方案是默认网站上存在多个视频，扩展会选择最后一个开始播放的视频。如果该视频暂停了，就会选择正在播放的视频中最后一个开始播放的视频，如果有的话。如果出现问题，用户依然可以通过**装填配置**来指定视频元素。

### 渲染

渲染弹幕主要的问题是如何保证弹幕始终显示在视频上方。

考虑的最坏情况是视频全屏，一般全屏是通过[`Top Layer`](https://developer.mozilla.org/en-US/docs/Glossary/Top_layer)实现的，所以弹幕也需要使用`Top Layer`，这样才能保证弹幕始终显示在视频上方。

这样做会导致无法实现弹幕互动，例如鼠标悬停、点击等。由于弹幕层在最上层，会遮挡下方的元素，比如视频控件等。如果要和下方的元素交互，就需要给弹幕层设置`pointer-events: none`，这样可以避免弹幕层拦截点击事件，但也导致弹幕无法接收用户互动。

### 限制

#### `iframe`

扩展脚本是以`frame`为单位注入的，主网页为一个`frame`，每个`iframe`都是单独的`frame`。每个`frame`都有自己的地址，`frame`之间的通信是受限的。

这会导致一些问题：比如视频嵌套在`iframe`中，而脚本是注入在主网页上的，主网页上的脚本无法直接访问`iframe`中的元素，也就无法检测到视频的播放状态和进行弹幕渲染。而如果将脚本注入到`iframe`中，又会导致无法访问主网页的元素（比如视频标题等），从而无法进行自动匹配。

为了解决这个问题，扩展的脚本拆分为两个模块：**控件**和**弹幕渲染器**，采取类似分布式系统的方式运作。

控件仅注入在主网页上，用于用户交互和控制，无法访问`iframe`中的元素。而弹幕渲染器注入在所有`frame`中（包括主网页），用于视频检测和弹幕渲染。

:::note
v0.16.0以前的版本，脚本只有一个，直接注入在主网页上。如果视频嵌套在`iframe`中，用户需要需要手动添加`iframe`的地址到**装填配置**中，以此来将脚本注入到`iframe`中。
:::

此外，控件还负责**弹幕渲染器**的注入和启动。以下为工作流程：

1. 控件注入
2. 控件从扩展后端获取网页中所有的`frame`
3. 控件将**弹幕渲染器**注入到所有`frame`中
4. 控件等待**弹幕渲染器**的启动，并完成握手
5. 控件等待**弹幕渲染器**的消息

控件和**弹幕渲染器**之间通过不通过`window.postMessage`，而是通过`chrome.runtime.sendMessage`。因为`frame`之间的通信非常麻烦，所有采用使用扩展后端作为中转。


但是也有一些问题：
- 视频在`iframe`中时无法使用画中画功能
- 如果存在多个`iframe`，并且多个`iframe`中都有视频，扩展无法判断哪个视频是用户正在观看的视频，可能会导致弹幕显示在错误的视频上

#### Shadow DOM

[Shadow DOM](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM) 会阻止脚本访问元素。

如果一个网站的视频元素位于 Shadow DOM 中，扩展无法直接访问到视频元素，导致无法正常工作。

目前无解，但也没有遇到过这种情况。
